# Tutorial 2: Hyperledger Fabric v1.2 - Create a Simple Smart Contract or Chaincode

In Hyperledger Fabric, **chaincode** is the ***smart contract*** that runs on the peers and creates transactions. More broadly, it enables users to create transactions in the Hyperledger Fabric network's shared ledger and update the world state of the assets.

Chaincode is programmable code, written in Go, and instantiated on a channel. Developers use chaincode to develop business contracts, asset definitions, and collectively-managed decentralized applications. The chaincode manages the ledger state through transactions invoked by applications. Assets are created and updated by a specifix chaincode, and cannot be accessed by another chaincode.

Applications interact with the blockchain ledger through the chaincode. Therefore, the chaincode needs to be installed on every peer that will endorse a transaction and instantiated on the channel.

## Chaincode Key API

To get the data by existing key in the state database
```go
func (stub *ChaincodeStub) GetState (key string) ([]byte, error)
```

To store the data with key in the state database
```go
func (stub *ChaincodeStub) PutState (key string, value []byte) error
```

To delete the data by the existing key in the state database
```go
func (stub *ChaincodeStub) DelState (key string) error
```

## Overview of a Chaincode Program
When creating a chaincode, there are two methods that you will need to implement:
- **Init**: Called when a chaincode receives an `instantiate` or `upgrade` transacton. This is where you will initialize any application state.
- **Invoke**: Called when the `invoke` transaction is received to process any transaction proposals.

As a developer, you must create both an `Init` and an `Invoke` method within your chaincode. The chaincode must be installed using the peer chaincode install command, and instantiated using `peer chaincode instantiate` command before the chaincode can be invoked. Then, transactions can be created using the `peer chaincode invoke` or `peer chaincode query` commands.

## Chaincode/Smart Contract Implementation:
### 1. Sample Chaincode Decomposed
#### 1.1. Dependencies

```go
package main
import (
    "fmt"
    "github.com/hyperledger/fabric/core/chaincode/shim"
    "github.com/hyperledger/fabric/protos/peer"
)
```
The `import` state lists a few dependencies that you will need for your chaincode to build successfully.
- `github.com/hyperledger/fabric/core/chaincode/shim` - contains the definition for the chaincode interface and the chaincode stub, which you will need to interact with the ledger, as we described in the `Chaincdoe Key APIs` section.
- `github.com/hyperledger/fabric/protos/peer` - contains the peer protobuf package.

#### 1.2. Struct
```go
// Sample SmartContract struct 
type SampleSmartContract struct {
}
```

This might not look like much, but this is the statement that begins the definition of an object/class in ***Go***. `SampleSmartContract` implements a simple chaincode to manage an asset.

#### 1.3. Init Method
Next, we'll implement the `Init` method. `Init` method is called during the chaincode instantiation to initialized data required by the application. In our sample, we will create the initial key/value pair for an asset, as specified on the command line:

```go
// Init Method of SampleChaincode
func (t *SampleSmartContract) Init(stub shim.ChainCodeStubInterface) peer.Response {
    // Get the args from the transaction proposal
    args := stub.GetStringArgs()
    if len(args) != 2 {
        return shim.Error("Incorrect arguments. Expecting a key and a value")
    }

    // We store the key and the value on the ledger
    err := stub.PutState(args[0], []byte(args[1]))
    // Check if it have any errors
    if err != nil {
        return shim.Error(fmt.Sprintf("Failed to create asset: %s", args[0]))
    }
    return shim.Success(nil)
}
```
#### 1.4. Invoke Method

```go
// Invoke Method of SampleChaincode
func (t *SampleSmartContract) Invoke(stub shim.ChaincodeStubInterface) peer.Response {
    // Extract the function and args from the transaction proposal
    fn, args := stub.GetFunctionAndParameters()
    var result string
    var err error

    // Invoke with set function
    if fn == "set" {
        if len(args) != 2 {
            return "", fmt.Errorf("Incorrect arguments. Expecting a key and a value")
        }
        err := stub.PutState(args[0], []byte(args[1]))
        if err != nil {
            return "", fmt.Errorf("Failed to set asset: %s", args[0])
        }
        result, err = args[0], nil

    // Invoke with get function
    } else if fn == "get" { 
        if len(args) != 1 {
            return "", fmt.Errorf("Incorrect arguments. Expecting a key")
        }
        value, err := stub.GetState(args[0])
        if err != nil {
            return "", fmt.Errorf("Failed to get asset: %s with error: %s", args[0], err)
        }
        if value == nil {
            return "", fmt.Errorf("Asset not found: %s", args[0])
        }
        result, err = string(value), nil
    }
    if err != nil { //Failed to get function and/or arguments from transaction proposal
        return shim.Error(err.Error())
    }
    // Return the result as success payload
    return shim.Success([]byte(result))
}

```
#### 1.5. Main Function
The last step of code is this sample is the `main` function, which will call the `Start` function. The `main` function starts the chaincode in the container during instantiation.

```go
// Main Function to start the SampleSmartContract
func main() {
    err := shim.Start(new(SampleSmartContract))
    if err != nil {
        fmt.Println("Could not start SampleSmartContract")
    } else {
        fmt.Println("SampleSmartContract successfully started")
    }
}
```

#### Sample Smart Contract Full Code in `main.go`
```go
package main
import (
    "fmt"
    "github.com/hyperledger/fabric/core/chaincode/shim"
    "github.com/hyperledger/fabric/protos/peer"
)

type SampleSmartContract struct {

}

// Init Method of SampleChaincode
func (t *SampleSmartContract) Init(stub shim.ChainCodeStubInterface) peer.Response {
    // Get the args from the transaction proposal
    args := stub.GetStringArgs()
    if len(args) != 2 {
        return shim.Error("Incorrect arguments. Expecting a key and a value")
    }

    // We store the key and the value on the ledger
    err := stub.PutState(args[0], []byte(args[1]))
    // Check if it have any errors
    if err != nil {
        return shim.Error(fmt.Sprintf("Failed to create asset: %s", args[0]))
    }
    return shim.Success(nil)
}

// Invoke Method of SampleChaincode
func (t *SampleSmartContract) Invoke(stub shim.ChaincodeStubInterface) peer.Response {
    // Extract the function and args from the transaction proposal
    fn, args := stub.GetFunctionAndParameters()
    var result string
    var err error

    // Invoke with set function
    if fn == "set" {
        if len(args) != 2 {
            return "", fmt.Errorf("Incorrect arguments. Expecting a key and a value")
        }
        err := stub.PutState(args[0], []byte(args[1]))
        if err != nil {
            return "", fmt.Errorf("Failed to set asset: %s", args[0])
        }
        result, err = args[0], nil

    // Invoke with get function
    } else if fn == "get" { 
        if len(args) != 1 {
            return "", fmt.Errorf("Incorrect arguments. Expecting a key")
        }
        value, err := stub.GetState(args[0])
        if err != nil {
            return "", fmt.Errorf("Failed to get asset: %s with error: %s", args[0], err)
        }
        if value == nil {
            return "", fmt.Errorf("Asset not found: %s", args[0])
        }
        result, err = string(value), nil
    }
    if err != nil { //Failed to get function and/or arguments from transaction proposal
        return shim.Error(err.Error())
    }
    // Return the result as success payload
    return shim.Success([]byte(result))
}

// Main Function to start the SampleSmartContract
func main() {
    err := shim.Start(new(SampleSmartContract))
    if err != nil {
        fmt.Println("Could not start SampleSmartContract")
    } else {
        fmt.Println("SampleSmartContract successfully started")
    }
}
```

## Example from StackOverFlow: **Usage of Query System chaincode**  (https://stackoverflow.com/questions/46440382/usage-of-query-system-chaincode)

First of all start with, you are not suppose to interact directly with a ledger structure from your chaincode, but rather to leverage existing APIs of `ChaincodeStubInterface` provided for `Invoke` and `Init` methods of chaincode.

Now, about the logic you are trying to achieve, one of the possible solutions would be to make use of `CreateCompositeKey` in the following way:
```go
func (s *SmartContract) Invoke(APIStub shim.chaincodeStubInterface) peer.Response {
    functionName, parameters := APIStub.GetFunctionAndParameters()

    indexName := "txID~key"

    if functionName == "addNewKey" {
        key := parameters[0]
        value := paramters[1]

        keyTxIdKey, err := APIStub.CreateCompositeKey(indexName, []string{APIStub.GetTxID(), key})

        if err != nil {
            return shim.Error(err.Error())
        }

        creator, _ := APIStub.GetCreator()

        // Add key and value to the state
        APIStub.PutState(key, []byte(value))
        APIStub.PutState(keyTxIdKey, creator)
    } else if functionName == "checkTxID" {
        txID := parameters[0]

        iterator, _ := APIStub.GetStateByPartialCompositeKey(indexName, []string{txID})

        for iterator.HasNext() {
            keyTxIdRange, err := iterator.Next()

            if err != nil {
                retrn shim.Error(err.Error())
            }

            _, keyParts, _ := APIStub.SplitCompositeKey(keyTxIdRange.Key)
            key := keyParts[1]

            fmt.Printf("Key affected by txID %s is %s\n", txID, key)

            txIDCreator := keyTxIdRange.Value

            sID := &msp.SerializedIdentity{}
            err := proto.Unmarsal(txIDCreator, sID)
            if err != nil {
                return shim.Error(fmt.Sprintf("Could not deserialize a SerializedIdentity, error %s", err))
            }

            bl, _ := pem.Decode(sID.IdBytes)

            if bl == nil {
                return shim.Error(fmt.Sprintf("Could not decode the PEM structure"))
            }

            certificate, err := x509.ParseCertificate(bl.Bytes)

            if err != nil {
                return shim.Error(fmt.Sprintf("ParseCertificate failed %s", err))
            }

            fmt.Printf("Certificate of txID %s creator is %s", txID, cert)
        }
    }
    return shim.Success(nil)
}
```