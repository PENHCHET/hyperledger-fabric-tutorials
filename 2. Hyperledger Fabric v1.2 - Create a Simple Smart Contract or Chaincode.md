# Tutorial 2: Hyperledger Fabric v1.2 - Create a Simple Smart Contract or Chaincode

In Hyperledger Fabric, **chaincode** is the ***smart contract*** that runs on the peers and creates transactions. More broadly, it enables users to create transactions in the Hyperledger Fabric network's shared ledger and update the world state of the assets.

Chaincode is programmable code, written in Go, and instantiated on a channel. Developers use chaincode to develop business contracts, asset definitions, and collectively-managed decentralized applications. The chaincode manages the ledger state through transactions invoked by applications. Assets are created and updated by a specifix chaincode, and cannot be accessed by another chaincode.

Applications interact with the blockchain ledger through the chaincode. Therefore, the chaincode needs to be installed on every peer that will endorse a transaction and instantiated on the channel.

- Golang Functions & Methods and Interfaces

First of all start with, you are not suppose to interact directly with a ledger structure from your chaincode, but rather to leverage existing APIs of `ChaincodeStubInterface` provided for `Invoke` and `Init` methods of chaincode.

Now, about the logic you are trying to achieve, one of the possible solutions would be to make use of `CreateCompositeKey` in the following way:
```go
func (s *SmartContract) Invoke(APIStub shim.chaincodeStubInterface) peer.Response {
    functionName, parameters := APIStub.GetFunctionAndParameters()

    indexName := "txID~key"

    if functionName == "addNewKey" {
        key := parameters[0]
        value := paramters[1]

        keyTxIdKey, err := APIStub.CreateCompositeKey(indexName, []string{APIStub.GetTxID(), key})

        if err != nil {
            return shim.Error(err.Error())
        }

        creator, _ := APIStub.GetCreator()

        // Add key and value to the state
        APIStub.PutState(key, []byte(value))
        APIStub.PutState(keyTxIdKey, creator)
    } else if functionName == "checkTxID" {
        txID := parameters[0]

        iterator, _ := APIStub.GetStateByPartialCompositeKey(indexName, []string{txID})

        for iterator.HasNext() {
            keyTxIdRange, err := iterator.Next()

            if err != nil {
                retrn shim.Error(err.Error())
            }

            _, keyParts, _ := APIStub.SplitCompositeKey(keyTxIdRange.Key)
            key := keyParts[1]

            fmt.Printf("Key affected by txID %s is %s\n", txID, key)

            txIDCreator := keyTxIdRange.Value

            sID := &msp.SerializedIdentity{}
            err := proto.Unmarsal(txIDCreator, sID)
            if err != nil {
                return shim.Error(fmt.Sprintf("Could not deserialize a SerializedIdentity, error %s", err))
            }

            bl, _ := pem.Decode(sID.IdBytes)

            if bl == nil {
                return shim.Error(fmt.Sprintf("Could not decode the PEM structure"))
            }

            certificate, err := x509.ParseCertificate(bl.Bytes)

            if err != nil {
                return shim.Error(fmt.Sprintf("ParseCertificate failed %s", err))
            }

            fmt.Printf("Certificate of txID %s creator is %s", txID, cert)
        }
    }
    return shim.Success(nil)
}
```

